"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const commandLineArgs = require("command-line-args");
const ts_node_1 = require("ts-node");
const path_1 = require("path");
const mongo_seeding_1 = require("mongo-seeding");
const options_1 = require("./options");
const help_1 = require("./help");
class CliSeeder {
    constructor() {
        this.DEFAULT_INPUT_PATH = './';
        this.run = () => __awaiter(this, void 0, void 0, function* () {
            let options;
            try {
                options = commandLineArgs(options_1.cliOptions);
            }
            catch (err) {
                this.printError(err);
                return;
            }
            if (help_1.shouldShowHelp(options)) {
                help_1.showHelp();
                return;
            }
            try {
                options_1.validateOptions(options);
            }
            catch (err) {
                this.printError(err);
                return;
            }
            const config = options_1.createConfigFromOptions(options);
            this.useCliSpecificOptions(config);
            const seeder = new mongo_seeding_1.Seeder(config);
            const collectionsPath = this.getCollectionsPath(options);
            const collectionReadingConfig = this.getCollectionReadingConfig(options);
            try {
                const collections = seeder.readCollectionsFromPath(path_1.resolve(collectionsPath), collectionReadingConfig);
                yield seeder.import(collections);
            }
            catch (err) {
                this.printError(err);
            }
            process.exit(0);
        });
        this.getCollectionReadingConfig = (options) => {
            const transformers = [];
            const replaceIdWithUnderscoreId = options['replace-id'] || process.env.REPLACE_ID === 'true';
            if (replaceIdWithUnderscoreId) {
                transformers.push(mongo_seeding_1.Seeder.Transformers.replaceDocumentIdWithUnderscoreId);
            }
            return {
                extensions: ['ts', 'js', 'json'],
                transformers,
            };
        };
        this.printError = (err) => {
            console.error(`Error ${err.name}: ${err.message}`);
            process.exit(0);
        };
    }
    getCollectionsPath(options) {
        if (options.data) {
            return options.data;
        }
        return this.DEFAULT_INPUT_PATH;
    }
    useCliSpecificOptions(options) {
        if (!options.silent) {
            // Enable debug output for Mongo Seeding
            process.env.DEBUG = 'mongo-seeding';
        }
        ts_node_1.register({
            transpileOnly: options.transpileOnly,
            compiler: require.resolve('typescript', { paths: [__dirname] }),
        });
    }
}
exports.cliSeeder = new CliSeeder();
//# sourceMappingURL=index.js.map